{"version":3,"sources":["js/bulletScreen.js"],"names":["bulletScreen","MAX_DM_COUNT","CHANNEL_COUNT","mark","domPool","danmuPool","hasPosition","init","wrapper","document","getElementById","j","doms","i","dom","createElement","appendChild","className","style","top","push","addEventListener","transform","getChannel","length","shootDanmu","text","channel","innerText","clientWidth","setTimeout","setInterval","shift","danmu"],"mappings":"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","file":"bulletScreen.5b43b0b4.map","sourceRoot":"..","sourcesContent":["  let bulletScreen = 6;\n\n  (function () {\n\n    /**\n     * 设置 弹幕DOM池 每一个通道最多六条弹幕\n     **/\n\n    const MAX_DM_COUNT = 6;\n    const CHANNEL_COUNT = 16;\n    let mark = true\n    let domPool = [];\n    let danmuPool = [\n      '微信关注公众号新之航软件，即可发送弹幕',\n    ];\n    let hasPosition = [];\n    /**\n     * 做一下初始化工作\n     */\n    function init() {\n      let wrapper = document.getElementById('wrapper')\n\n\n      // 先new一些span 重复利用这些DOM\n      for (let j = 0; j < CHANNEL_COUNT; j++) {\n        let doms = [];\n        for (let i = 0; i < MAX_DM_COUNT; i++) {\n          // 要全部放进wrapper\n          let dom = document.createElement('span');\n          wrapper.appendChild(dom);\n          // 初始化dom的位置 通过设置className\n          dom.className = 'right';\n          // DOM的通道是固定的 所以设置好top就不需要再改变了\n          dom.style.top = j * 2 + .5 + 'vw';\n          // 放入改通道的DOM池\n          doms.push(dom);\n          // 每次到transition结束的时候 就是弹幕划出屏幕了 将DOM位置重置 再放回DOM池\n          dom.addEventListener('transitionend', () => {\n\n            dom.className = 'right';\n            // dom.style.transition = null;\n            // dom.style.left = null;\n            dom.style.transform = null;\n            domPool[j].push(dom);\n          });\n        }\n        domPool.push(doms);\n      }\n      // hasPosition 标记每个通道目前是否有位置\n      for (let i = 0; i < CHANNEL_COUNT; i++) {\n        hasPosition[i] = true;\n      }\n    }\n\n    /**\n     * 获取一个可以发射弹幕的通道 没有则返回-1\n     */\n    function getChannel() {\n      for (let i = 0; i < CHANNEL_COUNT; i++) {\n        if (hasPosition[i] &&\n          domPool[i].length)\n          return i;\n      }\n      return -1;\n    }\n\n    /**\n     * 根据DOM和弹幕信息 发射弹幕\n     */\n    function shootDanmu(dom, text, channel) {\n      dom.innerText = text;\n      // 如果为每个弹幕设置 transition 可以保证每个弹幕的速度相同 这里没有保证速度相同\n      // dom.style.transition = `transform ${7 + dom.clientWidth / 100}s linear`;\n\n      // dom.style.left = '-' + dom.clientWidth + 'px';\n      // 设置弹幕的位置信息 性能优化 left -> transform\n      dom.style.transform = `translateX(${-dom.clientWidth}px)`;\n      dom.className = 'left';\n      hasPosition[channel] = false;\n      // 弹幕全部显示之后 才能开始下一条弹幕\n      // 大概 dom.clientWidth * 10 的时间 该条弹幕就从右边全部划出到可见区域 再加1秒保证弹幕之间距离\n      setTimeout(() => {\n        hasPosition[channel] = true;\n      }, dom.clientWidth * 10 + 1000);\n    }\n\n\n    init()\n    // 每隔1ms从弹幕池里获取弹幕（如果有的话）并发射\n\n    setInterval(() => {\n\n      if (mark) {\n        danmuPool.push('微信关注公众号新之航软件，即可发送弹幕')\n      }\n    }, 7000);\n    setInterval(() => {\n      let channel;\n      if (danmuPool.length && (channel = getChannel()) != -1) {\n        let dom = domPool[channel].shift();\n        let danmu = danmuPool.shift();\n        shootDanmu(dom, danmu, channel);\n      }\n    }, 17);\n\n  })()"]}